/*
Опрацювання масиву структур
*/

/*
Кожна програма має містити меню. Необхідно передбачити контроль помилок
користувача при введенні даних.
Необхідні програмі дані слід реалізувати за допомогою динамічного масиву
структур, кількість елементів у якому визначає користувач. Програма має
забезпечувати можливість зчитування всіх даних із файлу та запису всього масиву
у файл. Ім’я файлу має вводитися з клавіатури. При розробці програми застосувати
технологію низхідного проектування. Логічно закінчені фрагменти оформити у
вигляді функцій, всі необхідні дані яким передаються через список параметрів.
Використовувати глобальні змінні – не можна. Кожна функція має виконувати
лише одну роль, і ця роль має бути відображена у назві функції. «Функція, яка
повертає / обчислює / шукає ...» – має не виводити ці значення, а повернути їх у
місце виклику як результат функції або як відповідний вихідний параметр.
*/

/*
Варіант 14.

Описати структуру з іменем Note, що містить такі поля:
 прізвище, ім’я;
 номер телефону;
 день народження (масив з трьох чисел).
Написати програму, що виконує такі дії:
 введення даних з клавіатури в масив, що
складається з елементів
типу Note;  впорядкування масиву структур за
телефонними номерами;
 вивід на екран інформації про людину,
прізвище якої введене з клавіатури; якщо такої немає, вивести на екран
відповідне повідомлення.
*/
#include <fstream>
#include <iostream>
#include <limits>
#include <string>

using namespace std;

struct Note {
  string surname;
  string name;
  string phone;
  int birthday[3];
};

int getMenuChoice() {
  cout << "\n МЕНЮ \n"
       << "1. Ввести масив\n"
       << "2. Вивести масив\n"
       << "3. Сортувати за телефоном\n"
       << "4. Пошук за прізвищем\n"
       << "5. Запис у файл\n"
       << "6. Зчитати з файлу\n"
       << "0. Вихід\n"
       << "Ваш вибір: ";

  int c;
  while (!(cin >> c) || c < 0 || c > 6) {
    cin.clear();
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    cout << "Помилка! Введіть число (0–6): ";
  }
  return c;
}

int getPositiveInt(const string &msg) {
  int x;
  cout << msg;
  while (!(cin >> x) || x <= 0) {
    cin.clear();
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    cout << "Помилка! Введіть додатне число: ";
  }
  return x;
}

void inputNotes(Note *arr, int n) {
  for (int i = 0; i < n; i++) {
    cout << "\n Запис " << i + 1 << " \n";
    cout << "Прізвище: ";
    cin >> arr[i].surname;

    cout << "Ім'я: ";
    cin >> arr[i].name;

    cout << "Телефон: ";
    cin >> arr[i].phone;

    cout << "Дата народження (день місяць рік): ";
    cin >> arr[i].birthday[0] >> arr[i].birthday[1] >> arr[i].birthday[2];
  }
}

void printNote(const Note &a) {
  cout << "-----------------------------\n";
  cout << "Прізвище: " << a.surname << "\n";
  cout << "Ім'я: " << a.name << "\n";
  cout << "Телефон: " << a.phone << "\n";
  cout << "День народження: " << a.birthday[0] << "." << a.birthday[1] << "."
       << a.birthday[2] << "\n";
}

void printAll(const Note *arr, int n) {
  for (int i = 0; i < n; i++)
    printNote(arr[i]);
}

void sortByPhone(Note *arr, int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = i + 1; j < n; j++)
      if (arr[i].phone > arr[j].phone)
        swap(arr[i], arr[j]);
}

int findBySurname(const Note *arr, int n, const string &surname) {
  for (int i = 0; i < n; i++)
    if (arr[i].surname == surname)
      return i;
  return -1;
}

void saveToFile(const string &filename, const Note *arr, int n) {
  ofstream out(filename);
  if (!out) {
    cout << "Помилка відкриття файлу.\n";
    return;
  }

  out << n << "\n";
  for (int i = 0; i < n; i++) {
    out << arr[i].surname << " " << arr[i].name << " " << arr[i].phone << " "
        << arr[i].birthday[0] << " " << arr[i].birthday[1] << " "
        << arr[i].birthday[2] << "\n";
  }

  cout << "Дані збережені.\n";
}

bool loadFromFile(const string &filename, Note *&arr, int &n) {
  ifstream in(filename);
  if (!in)
    return false;

  int size;
  if (!(in >> size) || size <= 0)
    return false;

  Note *temp = new Note[size];

  for (int i = 0; i < size; i++) {
    if (!(in >> temp[i].surname >> temp[i].name >> temp[i].phone >>
          temp[i].birthday[0] >> temp[i].birthday[1] >> temp[i].birthday[2])) {
      delete[] temp;
      return false;
    }
  }

  delete[] arr;
  arr = temp;
  n = size;
  return true;
}

int main() {
  Note *notes = nullptr;
  int n = 0;

  while (true) {
    int choice = getMenuChoice();

    switch (choice) {
    case 1: {
      n = getPositiveInt("Введіть кількість записів: ");
      delete[] notes;
      notes = new Note[n];
      inputNotes(notes, n);
      break;
    }

    case 2: {
      if (n == 0) {
        cout << "Масив порожній.\n";
        break;
      }
      printAll(notes, n);
      break;
    }

    case 3: {
      if (n == 0) {
        cout << "Масив порожній.\n";
        break;
      }
      sortByPhone(notes, n);
      cout << "Відсортовано.\n";
      break;
    }

    case 4: {
      if (n == 0) {
        cout << "Масив порожній.\n";
        break;
      }
      cout << "Введіть прізвище: ";
      string s;
      cin >> s;
      int index = findBySurname(notes, n, s);
      if (index == -1)
        cout << "Не знайдено.\n";
      else
        printNote(notes[index]);
      break;
    }

    case 5: {
      cout << "Ім'я файлу: ";
      string f;
      cin >> f;
      saveToFile(f, notes, n);
      break;
    }

    case 6: {
      cout << "Ім'я файлу: ";
      string f;
      cin >> f;
      if (loadFromFile(f, notes, n))
        cout << "Файл успішно зчитано.\n";
      else
        cout << "Помилка читання файлу.\n";
      break;
    }

    case 0:
      delete[] notes;
      return 0;
    }
  }
}
